<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Esfera IA</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script>
    // ==== Configur√°veis ====
    let intensidade_resp = 0.4;
    let vel_resp = 100 + Math.random() * 50;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 5, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    const particleCount = 8000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      vertexColors: true,
      size: 0.02,
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    const currentForm = new Float32Array(particleCount * 3);
    const baseForm = new Float32Array(particleCount * 3);

    function generateForm(type) {
      const arr = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        let x = 0, y = 0, z = 0;

        if (type === 'sphere') {
          const phi = Math.acos(2 * Math.random() - 1);
          const theta = 2 * Math.PI * Math.random();
          const r = 1;
          x = r * Math.sin(phi) * Math.cos(theta);
          y = r * Math.sin(phi) * Math.sin(theta);
          z = r * Math.cos(phi);
        } else if (type === 'spiral') {
          const angle = i * 0.05;
          const radius = 0.5 + i * 0.0005;
          x = radius * Math.cos(angle);
          y = Math.sin(i * 0.01) * 0.8;
          z = radius * Math.sin(angle);
        } else if (type === 'interrogation') {
          const t = i / particleCount * 2 * Math.PI;
          x = 0.5 * Math.cos(t);
          y = 1.5 * Math.sin(t) - 0.5 * Math.abs(Math.sin(2 * t));
          z = (Math.random() - 0.5) * 0.1;
          if (i > particleCount * 0.9) {
            x = 0;
            y = -1.5 + (i - particleCount * 0.9) * 20 / particleCount;
            z = 0;
          }
        }

        arr[i3] = x;
        arr[i3 + 1] = y;
        arr[i3 + 2] = z;
      }
      return arr;
    }

    const sphereForm = generateForm('sphere');
    const spiralForm = generateForm('spiral');
    const interrogationForm = generateForm('interrogation');

    currentForm.set(sphereForm);
    baseForm.set(sphereForm);
    geometry.attributes.position.array.set(currentForm);
    geometry.attributes.position.needsUpdate = true;

    function applyGoldenColors() {
      for (let i = 0; i < particleCount * 3; i += 3) {
        colors[i] = 1.0;
        colors[i + 1] = 0.8;
        colors[i + 2] = 0.0;
      }
      geometry.attributes.color.needsUpdate = true;
    }

    applyGoldenColors();

    let morphing = false;

    function morphTo(newForm, duration = 1500, colorShift = true) {
      morphing = true;
      const from = currentForm.slice();
      anime({
        duration,
        easing: 'easeInOutQuad',
        update: function(anim) {
          const progress = anim.progress / 100;
          for (let i = 0; i < particleCount * 3; i++) {
            currentForm[i] = from[i] + (newForm[i] - from[i]) * progress;
            if (colorShift) {
              colors[i] = 1.0 - progress * 0.4;
              colors[i + 1] = 0.8 - progress * 0.3;
              colors[i + 2] = 0.0 + progress * 0.3;
            }
          }
          if (colorShift) geometry.attributes.color.needsUpdate = true;
        },
        complete: () => {
          baseForm.set(newForm);
          if (colorShift) applyGoldenColors();
          morphing = false;
        }
      });
    }

    window.addEventListener('keydown', (e) => {
      if (e.key === 'i' && !morphing) {
        morphTo(interrogationForm);
        spinAnimation();
        setTimeout(() => morphTo(sphereForm), 2000);
      }
    });

    function scheduleIdleBreath() {
      vel_resp = 1000 + Math.random() * 3000;
      const delay = vel_resp;

      setTimeout(() => {
        if (!morphing) {
          const tempForm = new Float32Array(particleCount * 3);
          const from = currentForm.slice();

          for (let i = 0; i < particleCount * 3; i++) {
            const disturb = (Math.random() - 0.5) * intensidade_resp;
            tempForm[i] = baseForm[i] + disturb;
          }

          anime({
            duration: 2500 + Math.random() * 1000,
            direction: 'alternate',
            easing: 'easeInOutQuad',
            update: function(anim) {
              const progress = anim.progress / 100;
              for (let i = 0; i < particleCount * 3; i++) {
                currentForm[i] = from[i] + (tempForm[i] - from[i]) * progress;
              }
            },
            complete: () => {
              scheduleIdleBreath();
            }
          });
        } else {
          scheduleIdleBreath();
        }
      }, delay);
    }

    scheduleIdleBreath();

    function spinAnimation() {
      const originalSpeedX = 0.0005;
      const originalSpeedY = 0.001;
      let spinProgress = 0;
      const spinDuration = 1000;
      const startTime = performance.now();

      function spinStep(currentTime) {
        const elapsed = currentTime - startTime;
        spinProgress = Math.min(elapsed / spinDuration, 1);
        const speedMultiplier = 1 + Math.sin(spinProgress * Math.PI) * 0.7;
        spinSpeedX = originalSpeedX * speedMultiplier;
        spinSpeedY = originalSpeedY * speedMultiplier;

        if (spinProgress < 1) {
          requestAnimationFrame(spinStep);
        } else {
          spinSpeedX = originalSpeedX;
          spinSpeedY = originalSpeedY;
        }
      }

      anime({
        targets: colors,
        0: 1.0, 1: 0.3, 2: 0.0,
        duration: spinDuration,
        direction: 'alternate',
        easing: 'easeInOutSine',
        update: () => {
          geometry.attributes.color.needsUpdate = true;
        },
        complete: () => {
          applyGoldenColors();
        }
      });

      requestAnimationFrame(spinStep);
    }

    let spinSpeedX = 0.0005;
    let spinSpeedY = 0.001;

    function animate() {
      requestAnimationFrame(animate);

      const posAttr = geometry.attributes.position;
      for (let i = 0; i < particleCount * 3; i++) {
        posAttr.array[i] = currentForm[i];
      }

      posAttr.needsUpdate = true;
      points.rotation.y += spinSpeedY;
      points.rotation.x += spinSpeedX;
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
