// ExplicaAI - API Principal
// Backend Node.js + Express integrado com Ollama + Gemma 3n + SQLite
// Hackathon: Gemma 3n Impact Challenge

const express = require('express');
const cors = require('cors');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const Database = require('./database');

const app = express();
const port = process.env.PORT || 3000;

// Inicializar database
const db = new Database();

console.log('üöÄ Iniciando ExplicaAI...');

// Configura√ß√£o do multer para upload de imagens
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const extension = path.extname(file.originalname);
    cb(null, `math_${timestamp}${extension}`);
  }
});

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB max
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Apenas imagens s√£o permitidas (JPEG, PNG, GIF)'));
    }
  }
});

// Middlewares
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Servir arquivos est√°ticos (frontend)
app.use(express.static('public'));
console.log('üìÅ Servindo arquivos est√°ticos da pasta public/');

// Servir arquivos da pasta uploads (para o frontend acessar imagens)
app.use('/uploads', express.static('uploads'));

// Middleware de log para debug
app.use((req, res, next) => {
  console.log(`üìç ${req.method} ${req.path}`);
  next();
});

// Criar pastas necess√°rias
const createDirectories = () => {
  const dirs = ['uploads', 'public'];
  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`üìÅ Pasta criada: ${dir}/`);
    }
  });
};

createDirectories();

// Fun√ß√£o para verificar se Ollama est√° rodando
const checkOllamaStatus = async () => {
  try {
    const fetch = (await import('node-fetch')).default;
    const response = await fetch('http://localhost:11434');
    const text = await response.text();
    return text.includes('Ollama is running');
  } catch (error) {
    return false;
  }
};

// Fun√ß√£o para chamar Ollama com error handling robusto
const callOllama = async (prompt, imagePath = null) => {
  const fetch = (await import('node-fetch')).default;
  
  const requestBody = {
    model: 'gemma3n:e4b',
    prompt: prompt,
    stream: false,
    options: {
      temperature: 0.3, // Mais determin√≠stico para matem√°tica
      top_p: 0.9,
      top_k: 40
    }
  };

  // Adicionar imagem se fornecida
  if (imagePath && fs.existsSync(imagePath)) {
    try {
      const imageBuffer = fs.readFileSync(imagePath);
      const base64Image = imageBuffer.toString('base64');
      requestBody.images = [base64Image];
      console.log(`üì∑ Imagem adicionada: ${path.basename(imagePath)}`);
    } catch (error) {
      console.error('‚ùå Erro ao processar imagem:', error.message);
      throw new Error('Erro ao processar a imagem');
    }
  }

  try {
    console.log('ü§ñ Enviando para Gemma 3n...');
    const startTime = Date.now();
    
    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
      timeout: 120000 // 2 minutos timeout
    });

    if (!response.ok) {
      throw new Error(`Ollama respondeu com status ${response.status}`);
    }

    const data = await response.json();
    const endTime = Date.now();
    
    console.log(`‚úÖ Resposta recebida em ${endTime - startTime}ms`);
    
    if (!data.response) {
      throw new Error('Resposta vazia do modelo');
    }
    
    return data.response;
  } catch (error) {
    console.error('‚ùå Erro ao chamar Ollama:', error.message);
    if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
      throw new Error('Timeout - o modelo est√° demorando muito para responder. Tente reiniciar o Ollama.');
    }
    throw new Error(`Erro na comunica√ß√£o com IA: ${error.message}`);
  }
};

// Prompts otimizados baseados nos testes
const createMathPrompt = (problem) => {
  return `Voc√™ √© um professor de matem√°tica muito did√°tico e paciente. Um estudante precisa de ajuda com este problema:

"${problem}"

Por favor, explique a solu√ß√£o seguindo este formato:

**An√°lise do Problema:**
[Identifique que tipo de problema √© e o que est√° sendo pedido]

**Solu√ß√£o Passo a Passo:**
1. [Primeiro passo com explica√ß√£o clara]
2. [Segundo passo com justificativa]
3. [Continue at√© resolver completamente]

**Verifica√ß√£o:**
[Confirme se a resposta est√° correta substituindo valores]

**Resposta Final:**
[Destaque a resposta de forma clara]

Use linguagem simples e did√°tica, como se estivesse explicando para um estudante do ensino m√©dio. Seja encorajador e paciente.`;
};

const createSimilarPrompt = (originalProblem) => {
  return `Baseado neste problema de matem√°tica: "${originalProblem}"

Crie 3 exerc√≠cios similares que:
- Sejam do mesmo tipo e n√≠vel de dificuldade
- Usem n√∫meros diferentes
- Mantenham a mesma estrutura de racioc√≠nio
- Sejam adequados para praticar o mesmo conceito

FORMATO DA RESPOSTA:
**Exerc√≠cio 1:**
[Problema similar com n√∫meros diferentes]

**Exerc√≠cio 2:**
[Outro problema similar]

**Exerc√≠cio 3:**
[Terceiro problema similar]

**Dica de Estudo:**
[Uma dica sobre como abordar este tipo de problema]

Certifique-se de que os exerc√≠cios sejam interessantes e realistas.`;
};

// ENDPOINTS DA API

// Route para p√°gina inicial (fallback)
app.get('/', (req, res) => {
  const indexPath = path.join(__dirname, 'public', 'index.html');
  console.log(`üìÑ Tentando servir: ${indexPath}`);
  
  if (fs.existsSync(indexPath)) {
    res.sendFile(indexPath);
  } else {
    res.status(404).json({
      error: 'Arquivo index.html n√£o encontrado',
      path: indexPath,
      suggestion: 'Verifique se o arquivo public/index.html existe'
    });
  }
});

// Status da aplica√ß√£o e Ollama
app.get('/api/status', async (req, res) => {
  try {
    const ollamaRunning = await checkOllamaStatus();
    
    res.json({
      status: 'ExplicaAI funcionando!',
      ollama: ollamaRunning ? 'online' : 'offline',
      model: 'gemma3n:e4b',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      version: '1.0.0'
    });
  } catch (error) {
    res.status(500).json({
      error: 'Erro ao verificar status',
      details: error.message
    });
  }
});

// Explicar problema digitado
app.post('/api/explain-text', async (req, res) => {
  try {
    const { problem, autoSave = false, collectionIds = [] } = req.body;
    
    if (!problem || problem.trim().length === 0) {
      return res.status(400).json({ 
        error: 'Problema n√£o fornecido',
        message: 'Por favor, digite um problema de matem√°tica para resolver.'
      });
    }

    if (problem.length > 1000) {
      return res.status(400).json({
        error: 'Problema muito longo',
        message: 'O problema deve ter no m√°ximo 1000 caracteres.'
      });
    }

    // Verificar se Ollama est√° rodando
    const ollamaStatus = await checkOllamaStatus();
    if (!ollamaStatus) {
      return res.status(503).json({
        error: 'Servi√ßo indispon√≠vel',
        message: 'O Ollama n√£o est√° rodando. Execute: ollama serve'
      });
    }

    const startTime = Date.now();
    const prompt = createMathPrompt(problem.trim());
    const explanation = await callOllama(prompt);
    const solvedTime = Math.round((Date.now() - startTime) / 1000);
    
    let savedProblem = null;
    
    // Salvar automaticamente se solicitado
    if (autoSave) {
      try {
        const category = await db.categorizeProblem(problem);
        const tags = [category.category.toLowerCase().replace(' ', '-')];

        const problemId = await db.saveProblem({
          text: problem.trim(),
          explanation,
          source: 'text',
          difficulty: 1,
          solvedTime,
          tags
        });

        // Adicionar √†s cole√ß√µes especificadas
        for (const collectionId of collectionIds) {
          await db.addProblemToCollection(problemId, collectionId);
        }

        // Auto-categoriza√ß√£o se n√£o especificou cole√ß√µes
        if (collectionIds.length === 0 && category.confidence > 0.6) {
          const suggestedCollection = await db.get("SELECT id FROM collections WHERE name = ?", [category.category]);
          if (suggestedCollection) {
            await db.addProblemToCollection(problemId, suggestedCollection.id);
          }
        }

        savedProblem = await db.getProblem(problemId);
        console.log(`üíæ Problema auto-salvo: "${problem.substring(0, 50)}..."`);
      } catch (saveError) {
        console.error('‚ö†Ô∏è Erro ao auto-salvar:', saveError.message);
        // Continuar mesmo se falhar o salvamento
      }
    }
    
    console.log(`‚úÖ Problema resolvido: "${problem.substring(0, 50)}..." em ${solvedTime}s`);
    
    res.json({
      success: true,
      problem: problem.trim(),
      explanation: explanation,
      timestamp: new Date().toISOString(),
      processingTime: `${solvedTime}s`,
      saved: !!savedProblem,
      savedProblem: savedProblem
    });

  } catch (error) {
    console.error('‚ùå Erro em explain-text:', error.message);
    res.status(500).json({ 
      error: 'Erro interno do servidor',
      message: error.message,
      suggestion: 'Verifique se o Ollama est√° rodando: ollama serve'
    });
  }
});

// OCR da imagem (retorna apenas o texto detectado)
app.post('/api/ocr-scan', upload.single('image'), async (req, res) => {
  let imagePath = null;
  
  try {
    if (!req.file) {
      return res.status(400).json({ 
        error: 'Imagem n√£o fornecida',
        message: 'Por favor, envie uma imagem com o problema de matem√°tica.'
      });
    }

    imagePath = req.file.path;
    console.log(`üì∑ Imagem recebida para OCR: ${req.file.filename}`);

    // Retornar informa√ß√µes da imagem para o frontend processar com Tesseract
    res.json({
      success: true,
      filename: req.file.filename,
      imagePath: `/uploads/${req.file.filename}`,
      message: 'Imagem recebida. Use Tesseract.js no frontend para OCR.',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erro em ocr-scan:', error.message);
    res.status(500).json({ 
      error: 'Erro ao processar imagem',
      message: error.message
    });
  }
  // N√ÉO remover arquivo - ser√° usado pelo frontend
});

// Explicar texto confirmado (ap√≥s OCR)
app.post('/api/explain-confirmed', async (req, res) => {
  try {
    const { confirmedText, originalImage, autoSave = false, collectionIds = [] } = req.body;
    
    if (!confirmedText || confirmedText.trim().length === 0) {
      return res.status(400).json({ 
        error: 'Texto n√£o fornecido',
        message: 'Por favor, confirme ou corrija o texto detectado pelo OCR.'
      });
    }

    // Verificar se Ollama est√° rodando
    const ollamaStatus = await checkOllamaStatus();
    if (!ollamaStatus) {
      return res.status(503).json({
        error: 'Servi√ßo indispon√≠vel',
        message: 'O Ollama n√£o est√° rodando. Execute: ollama serve'
      });
    }

    const startTime = Date.now();
    const prompt = createMathPrompt(confirmedText.trim());
    const explanation = await callOllama(prompt);
    const solvedTime = Math.round((Date.now() - startTime) / 1000);
    
    let savedProblem = null;
    
    // Salvar automaticamente se solicitado
    if (autoSave) {
      try {
        const category = await db.categorizeProblem(confirmedText);
        const tags = [category.category.toLowerCase().replace(' ', '-'), 'ocr'];

        const problemId = await db.saveProblem({
          text: confirmedText.trim(),
          explanation,
          source: 'ocr',
          difficulty: 1,
          solvedTime,
          tags
        });

        // Adicionar √†s cole√ß√µes especificadas
        for (const collectionId of collectionIds) {
          await db.addProblemToCollection(problemId, collectionId);
        }

        savedProblem = await db.getProblem(problemId);
        console.log(`üíæ Problema OCR auto-salvo: "${confirmedText.substring(0, 50)}..."`);
      } catch (saveError) {
        console.error('‚ö†Ô∏è Erro ao auto-salvar OCR:', saveError.message);
      }
    }
    
    console.log(`‚úÖ Texto confirmado resolvido: "${confirmedText.substring(0, 50)}..." em ${solvedTime}s`);
    
    res.json({
      success: true,
      originalText: confirmedText.trim(),
      explanation: explanation,
      timestamp: new Date().toISOString(),
      source: 'OCR + confirma√ß√£o do usu√°rio',
      processingTime: `${solvedTime}s`,
      saved: !!savedProblem,
      savedProblem: savedProblem
    });

    // Limpar arquivo da imagem ap√≥s processamento
    if (originalImage) {
      const imagePath = path.join('uploads', path.basename(originalImage));
      if (fs.existsSync(imagePath)) {
        try {
          fs.unlinkSync(imagePath);
          console.log(`üóëÔ∏è Arquivo removido ap√≥s confirma√ß√£o: ${path.basename(imagePath)}`);
        } catch (cleanupError) {
          console.error('‚ö†Ô∏è Erro ao remover arquivo:', cleanupError.message);
        }
      }
    }

  } catch (error) {
    console.error('‚ùå Erro em explain-confirmed:', error.message);
    res.status(500).json({ 
      error: 'Erro ao processar texto confirmado',
      message: error.message
    });
  }
});

// Gerar exerc√≠cios similares
app.post('/api/generate-similar', async (req, res) => {
  try {
    const { originalProblem } = req.body;
    
    if (!originalProblem || originalProblem.trim().length === 0) {
      return res.status(400).json({ 
        error: 'Problema original n√£o fornecido',
        message: 'Por favor, forne√ßa um problema base para gerar exerc√≠cios similares.'
      });
    }

    // Verificar se Ollama est√° rodando
    const ollamaStatus = await checkOllamaStatus();
    if (!ollamaStatus) {
      return res.status(503).json({
        error: 'Servi√ßo indispon√≠vel',
        message: 'O Ollama n√£o est√° rodando. Execute: ollama serve'
      });
    }

    const prompt = createSimilarPrompt(originalProblem.trim());
    const similarProblems = await callOllama(prompt);
    
    console.log(`‚úÖ Exerc√≠cios similares gerados para: "${originalProblem.substring(0, 50)}..."`);
    
    res.json({
      success: true,
      originalProblem: originalProblem.trim(),
      similarProblems: similarProblems,
      timestamp: new Date().toISOString(),
      count: 3
    });

  } catch (error) {
    console.error('‚ùå Erro em generate-similar:', error.message);
    res.status(500).json({ 
      error: 'Erro ao gerar exerc√≠cios similares',
      message: error.message
    });
  }
});

// Salvar problema resolvido
app.post('/api/problems/save', async (req, res) => {
  try {
    const { text, explanation, source = 'text', difficulty = 1, solvedTime = null, collectionIds = [] } = req.body;
    
    if (!text || !explanation) {
      return res.status(400).json({ 
        error: 'Dados incompletos',
        message: 'Texto do problema e explica√ß√£o s√£o obrigat√≥rios.'
      });
    }

    // Auto-categoriza√ß√£o
    const category = await db.categorizeProblem(text);
    const tags = [category.category.toLowerCase().replace(' ', '-')];

    // Salvar problema
    const problemId = await db.saveProblem({
      text: text.trim(),
      explanation,
      source,
      difficulty,
      solvedTime,
      tags
    });

    // Adicionar √†s cole√ß√µes especificadas
    for (const collectionId of collectionIds) {
      await db.addProblemToCollection(problemId, collectionId);
    }

    // Se n√£o especificou cole√ß√µes, sugerir categoria autom√°tica
    if (collectionIds.length === 0 && category.confidence > 0.6) {
      const suggestedCollection = await db.get("SELECT id FROM collections WHERE name = ?", [category.category]);
      if (suggestedCollection) {
        await db.addProblemToCollection(problemId, suggestedCollection.id);
      }
    }

    const savedProblem = await db.getProblem(problemId);
    
    console.log(`üíæ Problema salvo: "${text.substring(0, 50)}..."`);
    
    res.json({
      success: true,
      problem: savedProblem,
      suggestion: category,
      message: 'Problema salvo com sucesso!'
    });

  } catch (error) {
    console.error('‚ùå Erro ao salvar problema:', error.message);
    res.status(500).json({ 
      error: 'Erro ao salvar problema',
      message: error.message
    });
  }
});

// Listar problemas
app.get('/api/problems', async (req, res) => {
  try {
    const { 
      favorite, 
      status, 
      search, 
      collectionId, 
      limit = 20,
      page = 1 
    } = req.query;

    const filters = {};
    if (favorite === 'true') filters.favorite = true;
    if (status) filters.status = status;
    if (search) filters.search = search;
    if (collectionId) filters.collectionId = parseInt(collectionId);
    if (limit) filters.limit = parseInt(limit);

    const problems = await db.getProblems(filters);
    
    res.json({
      success: true,
      problems,
      total: problems.length,
      page: parseInt(page)
    });

  } catch (error) {
    console.error('‚ùå Erro ao listar problemas:', error.message);
    res.status(500).json({ 
      error: 'Erro ao listar problemas',
      message: error.message
    });
  }
});

// Buscar problema espec√≠fico
app.get('/api/problems/:id', async (req, res) => {
  try {
    const problem = await db.getProblem(req.params.id);
    
    if (!problem) {
      return res.status(404).json({
        error: 'Problema n√£o encontrado',
        message: 'O problema solicitado n√£o existe.'
      });
    }
    
    res.json({
      success: true,
      problem
    });

  } catch (error) {
    console.error('‚ùå Erro ao buscar problema:', error.message);
    res.status(500).json({ 
      error: 'Erro ao buscar problema',
      message: error.message
    });
  }
});

// Toggle favorito
app.put('/api/problems/:id/favorite', async (req, res) => {
  try {
    const isFavorite = await db.toggleFavorite(req.params.id);
    
    res.json({
      success: true,
      isFavorite,
      message: isFavorite ? 'Adicionado aos favoritos!' : 'Removido dos favoritos!'
    });

  } catch (error) {
    console.error('‚ùå Erro ao alterar favorito:', error.message);
    res.status(500).json({ 
      error: 'Erro ao alterar favorito',
      message: error.message
    });
  }
});

// Listar cole√ß√µes
app.get('/api/collections', async (req, res) => {
  try {
    const collections = await db.getCollections();
    
    res.json({
      success: true,
      collections
    });

  } catch (error) {
    console.error('‚ùå Erro ao listar cole√ß√µes:', error.message);
    res.status(500).json({ 
      error: 'Erro ao listar cole√ß√µes',
      message: error.message
    });
  }
});

// Criar nova cole√ß√£o
app.post('/api/collections', async (req, res) => {
  try {
    const { name, description, color, icon } = req.body;
    
    if (!name || name.trim().length === 0) {
      return res.status(400).json({ 
        error: 'Nome obrigat√≥rio',
        message: 'O nome da cole√ß√£o √© obrigat√≥rio.'
      });
    }

    const collectionId = await db.createCollection({
      name: name.trim(),
      description: description || '',
      color: color || '#4A90E2',
      icon: icon || 'üìö'
    });

    const collection = await db.get('SELECT * FROM collections WHERE id = ?', [collectionId]);
    
    res.json({
      success: true,
      collection,
      message: `Cole√ß√£o '${name}' criada com sucesso!`
    });

  } catch (error) {
    console.error('‚ùå Erro ao criar cole√ß√£o:', error.message);
    
    if (error.message.includes('UNIQUE constraint')) {
      res.status(400).json({ 
        error: 'Cole√ß√£o j√° existe',
        message: 'J√° existe uma cole√ß√£o com este nome.'
      });
    } else {
      res.status(500).json({ 
        error: 'Erro ao criar cole√ß√£o',
        message: error.message
      });
    }
  }
});

// Buscar problemas de uma cole√ß√£o
app.get('/api/collections/:id/problems', async (req, res) => {
  try {
    const problems = await db.getCollectionProblems(req.params.id);
    const collection = await db.get('SELECT * FROM collections WHERE id = ?', [req.params.id]);
    
    if (!collection) {
      return res.status(404).json({
        error: 'Cole√ß√£o n√£o encontrada',
        message: 'A cole√ß√£o solicitada n√£o existe.'
      });
    }
    
    res.json({
      success: true,
      collection,
      problems,
      total: problems.length
    });

  } catch (error) {
    console.error('‚ùå Erro ao buscar problemas da cole√ß√£o:', error.message);
    res.status(500).json({ 
      error: 'Erro ao buscar problemas da cole√ß√£o',
      message: error.message
    });
  }
});

// Adicionar problema √† cole√ß√£o
app.post('/api/problems/:problemId/collections/:collectionId', async (req, res) => {
  try {
    await db.addProblemToCollection(req.params.problemId, req.params.collectionId);
    
    res.json({
      success: true,
      message: 'Problema adicionado √† cole√ß√£o!'
    });

  } catch (error) {
    console.error('‚ùå Erro ao adicionar √† cole√ß√£o:', error.message);
    res.status(500).json({ 
      error: 'Erro ao adicionar √† cole√ß√£o',
      message: error.message
    });
  }
});

// Remover problema da cole√ß√£o
app.delete('/api/problems/:problemId/collections/:collectionId', async (req, res) => {
  try {
    await db.removeProblemFromCollection(req.params.problemId, req.params.collectionId);
    
    res.json({
      success: true,
      message: 'Problema removido da cole√ß√£o!'
    });

  } catch (error) {
    console.error('‚ùå Erro ao remover da cole√ß√£o:', error.message);
    res.status(500).json({ 
      error: 'Erro ao remover da cole√ß√£o',
      message: error.message
    });
  }
});

// Hist√≥rico de atividades
app.get('/api/history', async (req, res) => {
  try {
    const { limit = 50 } = req.query;
    const history = await db.getHistory(parseInt(limit));
    
    res.json({
      success: true,
      history,
      total: history.length
    });

  } catch (error) {
    console.error('‚ùå Erro ao buscar hist√≥rico:', error.message);
    res.status(500).json({ 
      error: 'Erro ao buscar hist√≥rico',
      message: error.message
    });
  }
});

// Estat√≠sticas gerais
app.get('/api/stats', async (req, res) => {
  try {
    const stats = await db.getStats();
    
    res.json({
      success: true,
      stats
    });

  } catch (error) {
    console.error('‚ùå Erro ao buscar estat√≠sticas:', error.message);
    res.status(500).json({ 
      error: 'Erro ao buscar estat√≠sticas',
      message: error.message
    });
  }
});

// Endpoint para testar conectividade
app.get('/api/test-ollama', async (req, res) => {
  try {
    const isRunning = await checkOllamaStatus();
    
    if (!isRunning) {
      return res.status(503).json({
        status: 'Ollama offline',
        message: 'Execute: ollama serve',
        instructions: [
          '1. Abra um terminal',
          '2. Execute: ollama serve', 
          '3. Em outro terminal: ollama run gemma3n:e4b',
          '4. Teste novamente esta API'
        ]
      });
    }

    // Teste simples com o modelo
    const testPrompt = 'Resolva: 2 + 2 = ?';
    const response = await callOllama(testPrompt);
    
    res.json({
      status: 'Ollama online',
      model: 'gemma3n:e4b',
      testResult: response,
      message: 'Sistema funcionando perfeitamente!'
    });

  } catch (error) {
    res.status(500).json({
      status: 'Erro no teste',
      error: error.message,
      suggestion: 'Verifique se o modelo gemma3n:e4b est√° baixado: ollama pull gemma3n:e4b'
    });
  }
});

// Middleware de tratamento de erros
app.use((error, req, res, next) => {
  console.error('‚ùå Erro n√£o tratado:', error);
  
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({
        error: 'Arquivo muito grande',
        message: 'A imagem deve ter no m√°ximo 5MB'
      });
    }
  }
  
  res.status(500).json({
    error: 'Erro interno do servidor',
    message: 'Algo deu errado. Tente novamente.'
  });
});

// Middleware 404
app.use((req, res) => {
  res.status(404).json({
    error: 'Endpoint n√£o encontrado',
    availableEndpoints: [
      'GET /api/status',
      'POST /api/explain-text',
      'POST /api/ocr-scan',
      'POST /api/explain-confirmed',
      'POST /api/generate-similar',
      'POST /api/problems/save',
      'GET /api/problems',
      'GET /api/collections',
      'GET /api/stats',
      'GET /api/test-ollama'
    ]
  });
});

// Inicializa√ß√£o do servidor
const startServer = async () => {
  try {
    // Inicializar database
    await db.init();
    console.log('üóÑÔ∏è Database SQLite inicializado com sucesso!');
    
    // Verificar se Ollama est√° rodando na inicializa√ß√£o
    const ollamaStatus = await checkOllamaStatus();
    
    app.listen(port, () => {
      console.log('='.repeat(60));
      console.log('üéØ ExplicaAI - Assistente de Matem√°tica Offline');
      console.log('='.repeat(60));
      console.log(`üöÄ Servidor rodando em: http://localhost:${port}`);
      console.log(`üìö Interface web: http://localhost:${port}`);
      console.log(`üîß Status API: http://localhost:${port}/api/status`);
      console.log(`ü§ñ Ollama: ${ollamaStatus ? '‚úÖ Online' : '‚ùå Offline'}`);
      console.log(`üóÑÔ∏è Database: ‚úÖ SQLite conectado`);
      console.log('='.repeat(60));
      
      if (!ollamaStatus) {
        console.log('‚ö†Ô∏è  ATEN√á√ÉO: Ollama n√£o est√° rodando!');
        console.log('   Execute em outro terminal: ollama serve');
        console.log('   Depois: ollama run gemma3n:e4b');
      }
      
      console.log('üìã APIs dispon√≠veis:');
      console.log('   ü§ñ POST /api/explain-text - Explicar problema');
      console.log('   üì∑ POST /api/explain-confirmed - Explicar ap√≥s OCR');
      console.log('   üíæ POST /api/problems/save - Salvar problema');
      console.log('   üìö GET /api/collections - Listar cole√ß√µes');
      console.log('   üìä GET /api/stats - Estat√≠sticas');
      console.log('='.repeat(60));
    });
  } catch (error) {
    console.error('‚ùå Erro ao inicializar servidor:', error);
    process.exit(1);
  }
};

// Tratamento de sinais do sistema
process.on('SIGINT', () => {
  console.log('\nüëã Encerrando ExplicaAI...');
  db.close();
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  console.error('üí• Erro n√£o capturado:', error);
  db.close();
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• Promise rejeitada:', reason);
  db.close();
  process.exit(1);
});

// Iniciar o servidor
startServer();
      